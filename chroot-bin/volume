#!/bin/sh

# This script uses cras_test_client to present an interface similar to the
# brightness script for crouton.

# Copyright (c) 2015 The crouton Authors. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#    * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

set -e
set -u

DEFAULT_VOLUME_DELTA=5

get_current_output() {
    # This function gets the current Output Node ID (x:y)

    # From cras_test_client we can get the current output node from
    # a specific line. This sed pipeline extracts it.
    # The line looks like this:
    #     Selected Output Node: 7:1
    cras_test_client --dump_server_info | sed -n \
        -e '/Selected Output Node/s#[[:space:]]*##g;s#^[a-zA-Z]*:##p'
    #       ^                     ^                 ^              ^ print
    #       ^                     ^                 ^ substitute letters
    #       ^                     ^ substitude spaces for nothing
    #       ^ select this line only
}

get_current_output_infos() {
    # This function gets line from cras_test_client --dump_server_info that 
    # represents the current state of the current output.

    # The current output informations will not duplicate an output node, this makes
    # it safe(-ish) to filter out on the current output ID.
    # This would also select the "Selected Output Node" line, but by filtering the
    # lines beginning with space characters, this selects the proper line.
    # If for any reason this starts failing, it could be replaced with a sed script
    # that acts only between the two "headers" "Output Nodes" and "Input Devices".
    cras_test_client --dump_server_info | grep "^[[:space:]].*$(get_current_output)"
}

get_current_volume() {
    get_current_output_infos | sed -e \
        "s#[[:space:]]\+#;#g" | cut -d';' -f3
    #    ^                        ^ Use cut to get the third field (Volume)
    #    ^ normalize spaces/tab separators to semicolons
}

set_volume() {
    local volume="$1"
    # Clamp volume to zero
    # A negative amount of absolute volume sets it to 100%
    if [ "$volume" -lt 0 ] ; then
        volume=0
    fi
    cras_test_client --set_node_volume "$(get_current_output):$volume"
}

get_is_muted() {
    local muted="$(host-dbus dbus-send --print-reply --system \
        --dest=org.chromium.cras --type=method_call \
        /org/chromium/cras org.chromium.cras.Control.GetVolumeState \
        | sed -n -e '6s/.*boolean[[:space:]]\+//p')"
    [ "$muted" = "true" ]
}

toggle_mute() {
    if get_is_muted; then
        unmute
    else
        mute
    fi
}

mute() {
    cras_test_client --user_mute 1
}
unmute() {
    cras_test_client --user_mute 0
}

relative_volume() {
    local delta="$1"
    if get_is_muted; then
        unmute
        if [ "$delta" -lt 0 ]; then
            set_volume 0
        fi
    else
        set_volume "$(( $(get_current_volume) + delta ))"
    fi
}

print_help() {
    local script="$(basename "$0")"
    echo "$script [set] [0-100]"
    echo "$script up|down [0-100]"
    echo "$script mute [set|unset|toggle]"
    echo ""
    echo "This script changes the volume of the current output"
    echo "device, as would changing it with the shortcut keys or"
    echo "with the GUI in Chrome OS."
    echo ""
    echo "Shortcut invocations:"
    echo "  $script up     increases by $DEFAULT_VOLUME_DELTA"
    echo "  $script down   decreases by $DEFAULT_VOLUME_DELTA"
    echo "  $script mute   sets muted"
    echo "  $script 0-100  sets volume to given value"
}

if [ $# -lt 1 ]; then
    print_help
    exit 0
fi

cmd="$1"
shift

if [ "$cmd" = "help" ] || [ "$cmd" = "-h" ] || [ "$cmd" = "--help" ]; then
    print_help
elif [ "$cmd" = "up" ]; then
    relative_volume "${2-$DEFAULT_VOLUME_DELTA}"
elif [ "$cmd" = "down" ]; then
    relative_volume "-${2-$DEFAULT_VOLUME_DELTA}"
elif [ "$cmd" = "mute" ]; then
    # Toggle cannot be used right now.
    action="${1-set}"
    if [ "$action" = "toggle" ]; then
        toggle_mute
    elif [ "$action" = "set" ]; then
        mute
    elif [ "$action" = "unset" ]; then
        unmute
    else
        echo "Invalid action: $action for mute."
        print_help
        exit 1
    fi
elif [ "$cmd" = "set" ]; then
    if [ $# -lt 1 ]; then
        echo "set needs an amount to set."
        print_help
        exit 1
    fi
    set_volume "$1"
elif [ "$cmd" -eq "$cmd" ] 2>/dev/null; then
    # Previous test tests for integer-ish value
    set_volume "$cmd"
else
    print_help
fi

# vim: noai:ts=4:sw=4:expandtab
