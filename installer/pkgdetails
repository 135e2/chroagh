#!/bin/sh -e
# Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# An adaption of pkgdetails.c from debootstrap into shell.

APPLICATION="${0##*/}"
USAGE="\
usage: $APPLICATION PKGS mirror packagesfile pkgs..
   or: $APPLICATION FIELD field mirror packagesfile pkgs..
   or: $APPLICATION GETDEPS packagesfile pkgs..
   or: $APPLICATION STANZAS packagesfile pkgs..
   or: $APPLICATION WGET% low high end reason"


# Parses a dependency list, spitting out the packages that are required, one per
# line. If multiple packages fulfil a dependency (as in, | is used), spits out
# the first one in the list.
# $*: dependency list
# Outputs to stdout.
outputdeps() {
    # Add an extra comma to remain to avoid special-casing
    local remain="${*%,}," dep ignore
    while [ -n "$remain" ]; do
        # Split at commas, and let shell strip out whitespace on dep
        dep=${remain%%,*}
        remain="${remain#*,}"
        [ -n "$dep" ] || continue
        # Grab the first item, ignoring anything else
        echo "$dep" | {
            IFS="$IFS|(" read dep ignore
            if [ -n "$dep" ]; then
                echo "$dep"
            fi
        }
    done
    return 0
}

# Parses a packages file to extract the dependencies for a set of packages.
# $1: pkgsfile
# $2+: packages
# Outputs a list of dependencies to stdout.
dogetdeps() {
    local pkgsfile="$1"
    shift
    local pkgs="$*" skip=y field data newpkgs
    while IFS=":" read field data; do
        case "$field" in
            [Pp][Aa][Cc][Kk][Aa][Gg][Ee])
                skip=y
                if [ -z "$pkgs" ]; then
                    return 0
                elif [ -z "$data" ]; then
                    continue
                fi
                newpkgs=''
                for pkg in $pkgs; do
                    if [ $data = "$pkg" ]; then
                        skip=n
                    else
                        newpkgs="$newpkgs $pkg"
                    fi
                done
                pkgs="$newpkgs";;
            *[Dd][Ee][Pp][Ee][Nn][Dd][Ss])
                if [ ! "$skip" = 'y' ]; then
                    outputdeps $data
                fi;;
        esac
    done < "$pkgsfile"
    return 0
}

# print out anything that looks like a % on its own line, appropriately scaled
# $1: int low
# $2: int high
# $3: int end
# $4: char *reason
dotranslatewgetpercent() {
    local input char lastval=0 val=0 low="$1" high="$2" ret=0
    local suffix="$3${4:+" "}$4"
    # Use the tr method if we have stdbuf, as it is way faster.
    if hash stdbuf 2>/dev/null; then
        stdbuf -oL tr -sc '[:digit:]%' '
' | {
            while read input; do
                    val="${input%"%"}"
                    if [ "$input" = "$val" ]; then
                        continue
                    fi
                    lastval="$val"
                    echo "P: $((val*(high-low)/100+low)) $suffix"
            done
            [ "$lastval" -eq 100 ]
        } || ret=1
    else
        # Otherwise we have to use the head method, which is CPU intensive.
        # Input may not have newlines, so process each character at a time.
        # Grabbing one byte at a time is terribly slow, so we grab batches.
        while input="`head -c8`"; do
            while [ -n "$input" ]; do
                char="${input%"${input#?}"}"
                input="${input#"$char"}"
                case "$char" in      
                    [0-9]) val=$((val*10+char));;
                    %) lastval="$val"
                       echo "P: $((val*(high-low)/100+low)) $suffix";;
                    *) val=0;;
                esac
            done
        done
        [ "$lastval" -eq 100 ] || ret=1
    fi
    return "$ret"
}


# Process command
extraparam=''
case "$1" in
    WGET%)   minparams=3; cmd=dotranslatewgetpercent;;
    GETDEPS) minparams=2; cmd=dogetdeps;;
    PKGS)    minparams=3; cmd=dopkgmirrorpkgs; extraparam='Package:';;
    FIELD)   minparams=4; cmd=dopkgmirrorpkgs;;
    STANZAS) minparams=2; cmd=dopkgstanzas;;
    *)       minparams=0; cmd='';;
esac

# Use -le to check number of parameters, since one parameter is the command.
if [ -z "$cmd" -o "$#" -le "$minparams" ]; then
    echo "$USAGE" 1>&2
    exit 1
fi

# Dispatch
shift
"$cmd" "$@" "$extraparam"
exit $?
