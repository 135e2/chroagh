#!/bin/sh -e
# Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# An adaption of pkgdetails.c from debootstrap into shell.

APPLICATION="${0##*/}"
USAGE="\
usage: $APPLICATION PKGS mirror packagesfile pkgs..
   or: $APPLICATION FIELD field mirror packagesfile pkgs..
   or: $APPLICATION GETDEPS packagesfile pkgs..
   or: $APPLICATION STANZAS packagesfile pkgs..
   or: $APPLICATION WGET% low high end reason"


# Parses a dependency list, spitting out the packages that are required, one per
# line. If multiple packages fulfil a dependency (as in, | is used), spits out
# the first one in the list.
# $*: dependency list
# Outputs to stdout.
outputdeps() {
    # Add an extra comma to remain to avoid special-casing
    local remain="${*%,}," dep ignore
    while [ -n "$remain" ]; do
        # Split at commas, and let shell strip out whitespace on dep
        dep=${remain%%,*}
        remain="${remain#*,}"
        [ -n "$dep" ] || continue
        # Grab the first item, ignoring anything else
        echo "$dep" | {
            IFS="$IFS|(" read dep ignore
            if [ -n "$dep" ]; then
                echo "$dep"
            fi
        }
    done
    return 0
}

# Parses a packages file to extract the dependencies for a set of packages.
# $1: pkgsfile
# $2+: packages
# Outputs a list of dependencies to stdout.
dogetdeps() {
    local pkgsfile="$1"
    shift
    local pkgs="$*" skip=y field data newpkgs
    while IFS=":" read field data; do
        case "$field" in
            [Pp][Aa][Cc][Kk][Aa][Gg][Ee])
                skip=y
                if [ -z "$pkgs" ]; then
                    return 0
                elif [ -z "$data" ]; then
                    continue
                fi
                newpkgs=''
                for pkg in $pkgs; do
                    if [ $data = "$pkg" ]; then
                        skip=n
                    else
                        newpkgs="$newpkgs $pkg"
                    fi
                done
                pkgs="$newpkgs";;
            *[Dd][Ee][Pp][Ee][Nn][Dd][Ss])
                if [ ! "$skip" = 'y' ]; then
                    outputdeps $data
                fi;;
        esac
    done < "$pkgsfile"
    return 0
}


# Searches a package list for a set of packages that have a field that matches
# the specified data.
# $1: unique; set to y to exit once all items have been found once.
# $2: fieldname
# $3: mirror
# $4: pkgsfile
# $5+: packages
# Outputs matching package data on stdout.
dopkgmirrorpkgs() {
    local unique="$1" targetfield="$2" mirror="$3" pkgsfile="$4"
    local checksumfield="${DEBOOTSTRAP_CHECKSUM_FIELD:-"MD5sum"}"
    shift 4
    local pkgs="$*" newpkgs skip='n'
    local curfield='' curpkg='' curver='' curarch=''
    local cursize='' curchecksum='' curfilename=''

    while IFS=":" read field data; do
        # Empty lines mark the start of new packages.
        if [ -z "$field" ]; then
            if [ ! "$skip" = 'y' -a -n "$curfield" ]; then
                echo $curpkg $curver $curarch $mirror \
                     $curfilename $curchecksum $cursize
                if [ -z "$pkgs" ]; then
                    break
                fi
            fi
            curfield=''
            skip='n'
            continue
        elif [ -z "$data" ]; then
            # Optimization: ignore lines with no data
            continue
        fi
        # Do a case-insensitive search on the field name
        if echo "$field:" | grep -qi "^$targetfield:*$"; then
            curfield="$data"
            # See if it's in our list, and for unique queries, remove the item.
            # Otherwise, mark the item as skip so that we don't have to parse
            # remaining fields.
            newpkgs=''
            skip='y'
            for pkg in $pkgs; do
                if [ $curfield = "$pkg" ]; then
                    skip='n'
                else
                    newpkgs="$newpkgs $pkg"
                fi
            done
            if [ "$unique" = 'y' ]; then
                pkgs="$newpkgs"
            fi
        fi
        # If we already know we don't care about this one, skip it.
        if [ "$skip" = 'y' ]; then
            continue
        fi
        # Case-insensitive search on the checksum field name
        if echo "$field:" | grep -qi "^$checksumfield:*$"; then
            curchecksum="$data"
        else
            # It might be one of the other fields
            case "$field" in
                [Pp][Aa][Cc][Kk][Aa][Gg][Ee])
                    curpkg="$data";;
                [Vv][Ee][Rr][Ss][Ii][Oo][Nn])
                    curver="$data";;
                [Aa][Rr][Cc][Hh][Ii][Tt][Ee][Cc][Tt][Uu][Rr][Ee])
                    curarch="$data";;
                [Ss][Ii][Zz][Ee])
                    cursize="$data";;
                [Ff][Ii][Ll][Ee][Nn][Aa][Mm][Ee])
                    curfilename="$data";;
            esac
        fi
    done < "$pkgsfile"

    # In unique mode, any that weren't found are returned as "pkg -"
    if [ "$unique" = 'y' ]; then
        for pkg in $pkgs; do
            echo $pkg -
        done
    fi

    return 0
}


# print out anything that looks like a % on its own line, appropriately scaled
# $1: int low
# $2: int high
# $3: int end
# $4: char *reason
dotranslatewgetpercent() {
    local input char lastval=0 val=0 low="$1" high="$2" ret=0
    local suffix="$3${4:+" "}$4"
    # Use the tr method if we have stdbuf, as it is way faster.
    if hash stdbuf 2>/dev/null; then
        stdbuf -oL tr -sc '[:digit:]%' '
' | {
            while read input; do
                    val="${input%"%"}"
                    if [ "$input" = "$val" ]; then
                        continue
                    fi
                    lastval="$val"
                    echo "P: $((val*(high-low)/100+low)) $suffix"
            done
            [ "$lastval" -eq 100 ]
        } || ret=1
    else
        # Otherwise we have to use the head method, which is CPU intensive.
        # Input may not have newlines, so process each character at a time.
        # Grabbing one byte at a time is terribly slow, so we grab batches.
        while input="`head -c8`"; do
            while [ -n "$input" ]; do
                char="${input%"${input#?}"}"
                input="${input#"$char"}"
                case "$char" in      
                    [0-9]) val=$((val*10+char));;
                    %) lastval="$val"
                       echo "P: $((val*(high-low)/100+low)) $suffix";;
                    *) val=0;;
                esac
            done
        done
        [ "$lastval" -eq 100 ] || ret=1
    fi
    return "$ret"
}


# Process command
extraparam=''
case "$1" in
    WGET%)   minparams=3; cmd=dotranslatewgetpercent;;
    GETDEPS) minparams=2; cmd=dogetdeps;;
    PKGS)    minparams=3; cmd=dopkgmirrorpkgs; extraparam='y Package:';;
    FIELD)   minparams=4; cmd=dopkgmirrorpkgs; extraparam='n';;
    STANZAS) minparams=2; cmd=dopkgstanzas;;
    *)       minparams=0; cmd='';;
esac

# Use -le to check number of parameters, since one parameter is the command.
if [ -z "$cmd" -o "$#" -le "$minparams" ]; then
    echo "$USAGE" 1>&2
    exit 1
fi

# Dispatch
shift
"$cmd" $extraparam "$@"
exit $?
